//
//  EratosfenWorker.swift
//  RPEratosfen
//
//  Created by Юрий on 27.05.17.
//  Copyright (c) 2017 Юрий. All rights reserved.
//
//  This file was generated by the Clean Swift HELM Xcode Templates
//  https://github.com/HelmMobile/clean-swift-templates

import Foundation

class EratosfenWorker {
    
    // MARK: Business Logic
    
    func eratosfen(number: Int, completionHandler: @escaping ([UInt]) -> Void) {
        NSLog("start simple eratosfen")
        var Sieve: [Bool] = [false, false]
        let sqrtNumber = Int(sqrt(Double(number)))
        
        for _ in 2...number {
            Sieve.append(true)
        }
        
        var k = 3
        while k <= sqrtNumber {
            var l = k * k
            
            while l <= number {
                Sieve[l] = false
                l += 2 * k
            }
            
            repeat {
                k += 2
            } while (!Sieve[k])
        }
        
        var result: [UInt] = [2]
        var i = 3
        while i <= number {
            if Sieve[i] {
                result.append(UInt(i))
            }
            i += 2
        }
        NSLog("finish simple eratosfen")
        completionHandler(result)
    }
    
    func eratosfenWheelFactorization(number: UInt,
                                     completionHandler: @escaping ([UInt]) -> Void) {

        // 5# 2 * 3 * 5
        let fprimes: [UInt] = [1, 7, 11, 13, 17, 19, 23, 29]
        
        let gaps: [[UInt]] = [[],
                              [3,  0,  5,  4,  2,  1,  6,  3],
                              [4,  6,  0,  8,  2,  10, 4,  6],
                              [3,  8,  7,  0,  12, 5,  4,  9],
                              [13, 6,  7,  16, 0,  9,  10, 3],
                              [12, 8,  18, 4,  14, 0,  10, 6],
                              [13, 22, 5,  8,  14, 17, 0,  9],
                              [28, 22, 18, 16, 12, 10, 6,  0]]
        
        let countEl: UInt = 10000;
        
        var result: [UInt] = []
        var maxk: [UInt] = []
        var waitResult = 0
        let queue = DispatchQueue.init(label: "com.llo8.RPEratosfen.EratosfenResult")
        
        NSLog("start eratosfen wheel factorization")
        for i in 0...7 {
            maxk.append(UInt((number - UInt(fprimes[i])) / 30))
        }
        
        var countStep = maxk.max()! / countEl
        if countStep * countEl < maxk.max()! {
            countStep += 1
        }
        
        for step in 0..<countStep {
            let startIndex = step * countEl
            
            var k: [UInt] = []
            for i in 0...7 {
               k.append(min(countEl, maxk[i] - startIndex))
            }
            
            var SieveWheelFact: [[Bool]] = []
            for i in 0...7 {
                var Sieve: [Bool] = []
                for _ in 0...k[i] {
                    Sieve.append(true)
                }
                SieveWheelFact.append(Sieve)
            }
            
            var wait = 0
            for col1 in 0...7 {
                wait += 1
                DispatchQueue.global().async {
                    for col2 in 1...7 {
                        var row = gaps[col2][col1]
                        
                        if startIndex > 0 {
                            row = row + fprimes[col2] - startIndex % fprimes[col2]
                        } else {
                            if row == 0 && step == 0 {
                                row += fprimes[col2]
                            }
                        }
                        
                        while row <= k[col1] {
                            SieveWheelFact[col1][Int(row)] = false
                            row += fprimes[col2]
                        }
                    }
                    wait -= 1
                }
            }
            
            while wait != 0 {
                sleep(1)
            }
            
            var tmpSieve = SieveWheelFact
            let index = startIndex
            let mk = k.max()!
            waitResult += 1
            
            queue.sync {
                for i in 0...mk {
                    for j in 0...7 {
                        if tmpSieve[j].first != nil {
                            if tmpSieve[j].first! {
                                result.append(UInt(30 * (i + index) + fprimes[j]))
                            }
                            tmpSieve[j].removeFirst()
                        }
                    }
                }
                waitResult -= 1
            }
        }
        
        while waitResult != 0 {
            sleep(1)
        }
        
        result.removeFirst()
        result.insert(2, at: 0)
        result.insert(3, at: 1)
        result.insert(5, at: 2)
        
        NSLog("finish eratosfen wheel factorization")
        completionHandler(result)
    }
}
